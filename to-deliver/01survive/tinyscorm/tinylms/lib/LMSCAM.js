/*
 * @(#)lmscam.js 1.2  2009-09-01
 *
 * Copyright (c) 2003-2009 Werner Randelshofer
 * Hausmatt 10, Immensee, CH-6405, Switzerland
 * All rights reserved.
 *
 * The copyright of this software is owned by Werner Randelshofer. 
 * You may not use, copy or modify this software, except in  
 * accordance with the license agreement you entered into with  
 * Werner Randelshofer. For details see accompanying license terms. 
 */ 
/**
 * This file contains Java Script prototypes that are used by lmsapi.js
 * to handle the metadata of a Content Aggregation Model (CAM).
 *
 * This file is intended to be included in the top level frameset of an 
 * eLearning course generated by TinyLMS.
 *
 * Example:
 * <html>
 *   <head>
 *     <title>Learning Management System</title>
 *     <script language="JavaScript" src="tinylms/lib/collections.js" type="text/JavaScript"></script>
 *     <script language="JavaScript" src="tinylms/lib/lms/lib/lmscam.js" type="text/JavaScript"></script>
 *   </head>
 * </html>
 *
 * Reference:
 * ADL (2001a). Advanced Distributed Learning.
 * Sharable Content Object Reference Model (SCORMï¿½) Version 1.2. 
 * Internet (2003-01-20): http://www.adlnet.org
 *
 * ADL (2001b). Advanced Distributed Learning.
 * SCORM 1.2 Runtime Environment. 
 * Internet (2003-01-20): http://www.adlnet.org
 *
 * @author Werner Randelshofer, Hausmatt 10, Immensee, CH-6405, Switzerland
 * @version 1.2 2009-09-01 Added Quiz element.
 * 1.1 2003-10-01 Constructor for User objects added. Constructor for ItemElement
 * extended.
 * 0.19 2003-03-28 Property isOrganizationElementItem renamed to isItemElement and
 * property isResource renamed to isResourceElement, property isOrganizationElement renamed
 * to isOrganizationElementElement.
 * 0.18 2003-03-26 Support for layered organization structures added.
 * 0.17 2003-03-16 Naming conventions for CAM elements streamlined with Java implementation.
 * 0.12 2003-03-05 Revised.
 * 0.1 2003-01-26 Created.
 */
 
var debug = false;
var debugResults = false;

/**
 * This is the constructor for an element of the Content Aggregation Model (CAM).
 */
function CAMElement() {
    this.identifier = null;
    this.identifierref = null;
    this.href = null;
	
    this.isOrganizationElement = false; // this attribute is set to true by OrganizationElement only
    this.isItemElement = false; // this attribute is set to true by ItemElement only
    this.isResourceElement = false; // this attribute is set to true by ResourceElement only
}
CAMElement.prototype = new TreeNode();
/**
 * Searches this subtree for a node with the specified identifier.
 */
CAMElement.prototype.findByIdentifier = function(identifier) {
  if (debug) alert("TreeNode.findByIdentifier("+identifier+")");
  if (identifier == this.identifier) return this;
  var result = null;
	for (var i=0; i < this.children.length; i++) {
	  result = this.children[i].findByIdentifier(identifier);
		if (result != null) break;
	}
  return result;
}
/**
 * Searches this subtree for a node with the specified identifierref.
 */
CAMElement.prototype.findByIdentifierref = function(identifierref) {
  if (debug) alert("CAMElement.findByIdentifierref("+identifierref+")");
  if (identifierref == this.identifierref) return this;
  var result = null;
	for (var i=0; i < this.children.length; i++) {
	  result = this.children[i].findByIdentifierref(identifierref);
		if (result != null) break;
	}
  return result;
}
/**
 * Searches this subtree for a node with the specified href.
 */
CAMElement.prototype.findByHRef = function(href) {
  if (debug) alert("CAMElement.findByHRef("+href+")");
  if (href == this.href) return this;
  var result = null;
	for (var i=0; i < this.children.length; i++) {
	  result = this.children[i].findByHRef(href);
		if (result != null) break;
	}
  return result;
}


/**
 * This is the constructor for a CAM manifest element.
 */
function ManifestElement(identifier,version,organizations,resources) {
    this.identifier = identifier;
    this.version = version;
	
    this.organizations = (organizations != null) ? organizations : new OrganizationsElement(null);
    this.resources = (resources != null) ? resources : new ResourcesElement(null);
	
    this.add(this.organizations);
    this.add(this.resources);
}
ManifestElement.prototype = new CAMElement();

/**
 * This is the constructor for a CAM organizations node.
 */
function OrganizationsElement(children) {
  if (children != null) {
		for (var i=0; i < children.length; i++) {
			this.add(children[i]);
		}  
	}
}
OrganizationsElement.prototype = new CAMElement();

/**
 * This is the constructor for a CAM organization element.
 */
function OrganizationElement(identifier,title,children) {
  this.identifier = identifier;
	this.title = title;
	this.isOrganizationElement = true; // this attribute is set to true by OrganizationElement only
  for (var i=0; i < children.length; i++) {
	  this.add(children[i]);
	}
	
}
OrganizationElement.prototype = new CAMElement();
/**
 * Returns the column item of the specified item.
 * This method is used only for layered organization structures.
 * Returns null if the item is not in a column of this organization.
 */
OrganizationElement.prototype.getColumnOfItem = function(itemElement) {
  var column = null;
	var row = itemElement;
	while (row != null && row.getParent() != this) {
	  column = row;
		row = row.getParent();
	}
	// this should never happen
	if (row == null) {
	  //alert("OrganizationElement.getColumnOfItem()\nItem is not part of this organization\nItem:"+itemElement+" title="+itemElement.title+" id="+itemElement.identifier);
		return null;
	}
	
	return column;
}
/**
 * Returns the row item of the specified item.
 * This method is used only for layered organization structures.
 * Returns null if the item is not in a row of this organization.
 */
OrganizationElement.prototype.getRowOfItem = function(itemElement) {
	var row = itemElement;
	while (row != null && row.getParent() != this) {
		row = row.getParent();
	}
	// this should never happen
	if (row == null) {
	  //alert("OrganizationElement.getRowOfItem()\nItem is not part of this organization\nItem:"+itemElement+" title="+itemElement.title+" id="+itemElement.identifier);
		return null;
	}
	return row;
}

/**
 * This is the constructor for a CAM organization item element.
 */
function ItemElement(identifier,title,resourceref,parameters,dataFromLMS,children) {
    this.isItemElement = true;
    this.identifier = identifier;
    this.title = title;
    this.resourceref = resourceref;
    this.parameters = parameters;
    this.dataFromLMS = dataFromLMS;
    if (children != null) {
        for (var i=0; i < children.length; i++) {
            this.add(children[i]);
        }
    }
    this.resource = null; // this attribute is used by getResource()
    this.isExpanded = false; // this attribute is used to expand and collapse tree nodes in lmstoc.js
}
ItemElement.prototype = new CAMElement();

/** Get resource from item. THe manifest parameter is optional. */
ItemElement.prototype.getResource = function(manifest) {
    if (this.resourceref == null) return null;

    if (this.resource == null) {
        // find the root node if the manifest is not supplied. The root node must be of type manifest
        if (manifest==null) {
            manifest = this.getRoot();
        }
        if (manifest.resources == null) alert('Error in LMSCAM.js - item has not manifest as root. item.identifier:'+this.identifier+" root.identifier:"+manifest.identifier);
        this.resource = manifest.resources.findByIdentifier(this.resourceref);
    }
    return this.resource;
}

ItemElement.prototype.getHRef = function() {
  var r = this.getResource();
	return (r == null) ? null : r.href;
}
/** Returns true, if subtree starting at this item should be listed in
 * the TOC.
 * Items which dynamically change the sequencing of their subtree
 * are not traversable.
 */
ItemElement.prototype.isTraversable = function() {
    return true;
}
/** Updates the sequencing in the subtree of this item.
 */
ItemElement.prototype.updateSequencing = function() {
}
 
/**
 * This is the constructor for a TinyLMS-specific quiz element.
 */
function QuizElement(identifier,title,maxQuiz,quizItems) {
    // call parent constructor
    ItemElement.call(this, identifier, title, null, null, null, []);

    this.maxQuiz = maxQuiz; // limits the number of items shown per quiz
    this.quizItems = quizItems;

    // Add initial quiz items as children
    for (var i=0; i < quizItems.length && i < maxQuiz; i++) {
        this.add(quizItems[i]);
    }

    this.resultsItem = new ItemElement(identifier+"_results_item",API.labels.get("quiz.results.title"),identifier+"_results_resource",null,"quiz="+identifier);
    this.resultsItem.resource = new ResourceElement(identifier+"_results_resource","../tinylms/lmsquizresults.html")
}
QuizElement.prototype = new ItemElement();

/** Returns false, because it does not make sense to list the child
 * elements in the TOC, because they change every time the quiz is
 * started. */
QuizElement.prototype.isTraversable = function() {
    return true;
}
/** Updates the sequencing in the subtree of this item.
 * Randomly picks up to 5 new child elements.
 */
QuizElement.prototype.updateSequencing = function() {
    this.removeAllChildren();

    // Fisher-Yates shuffle of array a
    var a = this.quizItems.slice();
    for (var n=a.length - 1; n > 0;n--) {
        var k = Math.floor(Math.random()*(n+1));  // 0 <= k <= n.
        var tmp = a[k];
        a[k] = a[n];
        a[n] = tmp;
    }

    var manifest = this.getRoot();

    // First add items which the user hasn't seen yet
    var i;
    for (i=0; i < a.length && this.getChildCount() < this.maxQuiz; i++) {
        if (a[i].getResource(manifest).cmi_core_lesson_status=='not attempted') {
            this.add(a[i]);
        }
    }
    // Next add items which the user has failed yet
    for (i=0; i < a.length && this.getChildCount() < this.maxQuiz; i++) {
        if (a[i].getResource(manifest).cmi_core_lesson_status=='failed') {
            this.add(a[i]);
        }
    }
    // Next add all other items
    for (i=0; i < a.length && this.getChildCount() < this.maxQuiz; i++) {
        if (a[i].getResource(manifest).cmi_core_lesson_status != 'not attempted' &&
            a[i].getResource(manifest).cmi_core_lesson_status != 'failed') {
            this.add(a[i]);
        }
    }

    // Add quiz results item
    this.add(this.resultsItem);
}

/**
 * This is the constructor for a CAM resources node.
 */
function ResourcesElement(children) {
  if (children != null) {
		for (var i=0; i < children.length; i++) {
			this.add(children[i]);
		}  
	}
}
ResourcesElement.prototype = new CAMElement();

/**
 * This is the constructor for a CAM resource element.
 */
function ResourceElement(identifier,href) {
    this.identifier = identifier;
    this.href = href;
    this.isResourceElement = true;

    // Please note: If you add or remove entries here, you have to
    // change lmsapi.js as well.
    this.cmi_core_lesson_location = ""; // "cmi.core.lesson_location" is used by lmsapi.js
    this.cmi_core_credit = "credit"; // "cmi.core.credit" is used by lmsapi.js
    this.cmi_core_lesson_status = "not attempted"; // "cmi.core.lesson_status" is used by lmsapi.js
    this.cmi_core_entry = ""; // "cmi.core.entry" is used by lmsapi.js
    this.cmi_core_score_raw = ""; // "cmi.core.score.raw" is used by lmsapi.js
    this.cmi_core_total_time = "0000:00:00.00"; // "cmi.core.total_time" is used by lmsapi.js
    this.cmi_core_exit = ""; // "cmi.core.exit" is used by lmsapi.js
    this.cmi_core_session_time = ""; // "cmi.core.session_time" is used by lmsapi.js
    this.cmi_suspend_data = ""; // "cmi.suspend_data" is used by lmsapi.js
}
ResourceElement.prototype = new CAMElement();

var LMSCAM = new ManifestElement("identifier","1.0",null,null);


/**
 * This is the constructor for a user object.
 */
function User(identifier,passwordDigest,name) {
  this.identifier = identifier;
	this.passwordDigest = passwordDigest;
	this.name = name;
}
/**
 * Verifies a password.
 */
User.prototype.isPasswordValid = function(password) {
	LoggerSingleton.write(LoggerSingleton.INTERNAL,"User.isPasswordValid(*****)");
	if (this.passwordDigest == null) return true;
	if (password == null) return false;
	
	var pos = this.passwordDigest.indexOf('.');
	var digest = hex_sha1(this.passwordDigest.substring(0, pos)+password);
	var isValid = digest == this.passwordDigest.substring(pos + 1);
	LoggerSingleton.write(
		(isValid) ? LoggerSingleton.INTERNAL_SUCCESS : LoggerSingleton.INTERNAL_FAILURE,
		"User.isPasswordValid: "+isValid
	);
	return isValid;
}

